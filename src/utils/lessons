# ALPHA VERSION CODEBASE LESSONS & INSIGHTS
# ===================================
# This file records important learnings about the codebase

## Alpha Version Architecture
1. The application follows a modular architecture with clear separation of concerns
2. UI components are managed by specialized controller classes
3. Simulation logic is encapsulated in the SimulationEngine
4. Component system provides extensible power system modeling

BorderedMainWidget uses a flash system with different color palettes for different types of notifications, with timer-based animations.

UI animations with sequential color changes can create a more visually engaging effect than alternating patterns
Component initialization order is critical - ensure windows are fully initialized before loading scenarios to prevent display issues
QTimer.singleShot() can be used to create sequential animations without the need for a dedicated animation framework
When animating UI components that have functional signals, temporarily disconnect them to prevent unintended side effects during animations

Alpha users need clear instructions on bypassing OS security for unsigned apps (Windows/macOS).

Tab key can cause issues as a global hotkey when compiled on Windows; switched to Backslash.
README needs sufficient detail on core features like panels, views, Autocomplete, and metrics (CAPEX/IRR) for alpha users.

- Noted that README.txt now utilizes emojis and reorganized sections for better alpha user guidance.

- GitHub Actions workflows should include documentation files (like README.txt) alongside executables in distribution artifacts.

macOS ditto command can't archive multiple source files directly - use zip instead for packaging multiple files together

Refactoring property handler methods into separate modules improves maintainability while keeping same API for component integration

The pattern for extracting component properties involves creating a dedicated function in a separate file and updating the original method to import and call this function.

For syncing animations between components, it's better to create a central update method than duplicate animation logic.

Using the singleton pattern with static class variables (_instance) allows accessing UI components from anywhere without passing references.
The TerminalWidget._instance pattern enables logging from any part of the app without direct references, useful for component addition tracking.

Use TerminalWidget.log() for error messages instead of QMessageBox to show errors in the terminal UI component.
Terminal logging for state changes (simulation starting/pausing) improves UX by providing clear feedback on application state transitions.

Using TerminalWidget.log is preferred over QMessageBox for non-critical notifications as it avoids interrupting the user workflow.

When implementing component maintenance or outage features, all related functions must check the maintenance status, especially when components interact with each other (e.g., generators charging batteries).

Using consistent color coding throughout the UI (green for revenue/profit, red for costs) helps create a cohesive visual language that improves data interpretation.

Decorative components (trees, bushes, ponds, etc.) don't need functional UI elements like info boxes since they're purely visual.

The IconStateButton class provides a reusable way to create buttons with different icon states (normal/hover/pressed) by dynamically modifying pixmap brightness.

Following the DRY (Don't Repeat Yourself) principle by importing shared style definitions from a central location improves maintainability and ensures consistency across the UI.

Variables meant to be imported by other modules must be defined at the module level, not inside classes or methods, to be accessible via direct import statements.

In QGraphicsScene, items added later appear on top of items added earlier - use this layering system to control visual hierarchy (e.g., masks over videos/logos).

For UI overlays that need fixed positioning relative to screen edges, make them children of the view widget and handle repositioning in the resize event handler, similar to analytics container pattern.
Particle effects for component lifecycle: capture component position before removing from scene, then create effect at that position after removal for visual consistency.

QDialog styling can match properties panel theme using rgba(37, 47, 52, 0.95) background and consistent fonts/colors - use setFixedSize() for popup dimensions.
