# ALPHA VERSION CODEBASE LESSONS & INSIGHTS
# ===================================
# This file records important learnings about the codebase

## Alpha Version Architecture
1. The application follows a modular architecture with clear separation of concerns
2. UI components are managed by specialized controller classes
3. Simulation logic is encapsulated in the SimulationEngine
4. Component system provides extensible power system modeling

BorderedMainWidget uses a flash system with different color palettes for different types of notifications, with timer-based animations.

UI animations with sequential color changes can create a more visually engaging effect than alternating patterns
Component initialization order is critical - ensure windows are fully initialized before loading scenarios to prevent display issues
QTimer.singleShot() can be used to create sequential animations without the need for a dedicated animation framework
When animating UI components that have functional signals, temporarily disconnect them to prevent unintended side effects during animations

Alpha users need clear instructions on bypassing OS security for unsigned apps (Windows/macOS).

Tab key can cause issues as a global hotkey when compiled on Windows; switched to Backslash.
README needs sufficient detail on core features like panels, views, Autocomplete, and metrics (CAPEX/IRR) for alpha users.

- Noted that README.txt now utilizes emojis and reorganized sections for better alpha user guidance.

- GitHub Actions workflows should include documentation files (like README.txt) alongside executables in distribution artifacts.

macOS ditto command can't archive multiple source files directly - use zip instead for packaging multiple files together

Refactoring property handler methods into separate modules improves maintainability while keeping same API for component integration

The pattern for extracting component properties involves creating a dedicated function in a separate file and updating the original method to import and call this function.

For syncing animations between components, it's better to create a central update method than duplicate animation logic.

Using the singleton pattern with static class variables (_instance) allows accessing UI components from anywhere without passing references.
The TerminalWidget._instance pattern enables logging from any part of the app without direct references, useful for component addition tracking.

Use TerminalWidget.log() for error messages instead of QMessageBox to show errors in the terminal UI component.
Terminal logging for state changes (simulation starting/pausing) improves UX by providing clear feedback on application state transitions.

Using TerminalWidget.log is preferred over QMessageBox for non-critical notifications as it avoids interrupting the user workflow.

When implementing component maintenance or outage features, all related functions must check the maintenance status, especially when components interact with each other (e.g., generators charging batteries).

Using consistent color coding throughout the UI (green for revenue/profit, red for costs) helps create a cohesive visual language that improves data interpretation.

Decorative components (trees, bushes, ponds, etc.) don't need functional UI elements like info boxes since they're purely visual.

The IconStateButton class provides a reusable way to create buttons with different icon states (normal/hover/pressed) by dynamically modifying pixmap brightness.

Following the DRY (Don't Repeat Yourself) principle by importing shared style definitions from a central location improves maintainability and ensures consistency across the UI.

Variables meant to be imported by other modules must be defined at the module level, not inside classes or methods, to be accessible via direct import statements.

In QGraphicsScene, items added later appear on top of items added earlier - use this layering system to control visual hierarchy (e.g., masks over videos/logos).

For UI overlays that need fixed positioning relative to screen edges, make them children of the view widget and handle repositioning in the resize event handler, similar to analytics container pattern.
Particle effects for component lifecycle: capture component position before removing from scene, then create effect at that position after removal for visual consistency.

QDialog styling can match properties panel theme using rgba(37, 47, 52, 0.95) background and consistent fonts/colors - use setFixedSize() for popup dimensions.

- QAction lives in QtGui, not QtWidgets, in PyQt6 – import paths must be updated during migration.

- QMediaContent removed in PyQt6; use QMediaPlayer.setSource(QUrl) instead of setMedia(QMediaContent(url)).

- QSizePolicy enums moved inside QSizePolicy.Policy in PyQt6 – use QSizePolicy.Policy.Fixed/Expanding/Preferred etc.

- Qt.ScrollBarAlwaysOff moved: use Qt.ScrollBarPolicy.ScrollBarAlwaysOff in PyQt6.

- QFrame.HLine now QFrame.Shape.HLine; similarly QFrame.Shadow.* enums in PyQt6.

- Qt.WA_TransparentForMouseEvents now Qt.WidgetAttribute.WA_TransparentForMouseEvents in PyQt6.

- Qt.TopLeftCorner etc. are now Qt.Corner.TopLeftCorner in PyQt6.

- QGraphicsView.ScrollHandDrag / NoDrag now in QGraphicsView.DragMode.* in PyQt6.

- QPainter.Antialiasing now QPainter.RenderHint.Antialiasing; similar for SmoothPixmapTransform.

- QGraphicsView.FullViewportUpdate now QGraphicsView.ViewportUpdateMode.FullViewportUpdate.

- Qt.StrongFocus / NoFocus now Qt.FocusPolicy.StrongFocus / NoFocus.

- event.KeyPress etc. replaced by QEvent.Type.KeyPress etc. in PyQt6.

- Qt.RichText -> Qt.TextFormat.RichText.

- QDockWidget.NoDockWidgetFeatures -> QDockWidget.DockWidgetFeature.NoDockWidgetFeatures in PyQt6.

- QToolButton.InstantPopup now QToolButton.ToolButtonPopupMode.InstantPopup.

- QApplication.desktop() removed; use QGuiApplication.primaryScreen().availableGeometry().

- Qt.FramelessWindowHint -> Qt.WindowType.FramelessWindowHint.

- Qt.ArrowCursor etc. moved to Qt.CursorShape.*

- QMediaPlayer(None, QMediaPlayer.VideoSurface) obsolete; just QMediaPlayer() and setVideoOutput().

- Color constants now in Qt.GlobalColor; pen/brush styles in Qt.PenStyle/BrushStyle; update SolidLine, RoundCap, RoundJoin accordingly.

- Qt.DirectConnection constant is now Qt.ConnectionType.DirectConnection.

- Qt.Key.* enums now Qt.Key.Key_* (e.g., Key_Delete, Key_Return...).

- Qt.IntersectClip -> Qt.ClipOperation.IntersectClip; Qt.transparent constant now Qt.GlobalColor.transparent.

- QMessageBox.Yes/No/Cancel button constants now in QMessageBox.StandardButton.* in PyQt6.

- QDialog.Accepted/Rejected constants now in QDialog.DialogCode.* in PyQt6.

PyInstaller bundles external binaries like FFmpeg in sys._MEIPASS directory when frozen - use getattr(sys, 'frozen', False) to detect compiled state.
Setting PATH environment variable to include sys._MEIPASS helps Qt find bundled FFmpeg binaries for video playback in compiled applications.
Using multiple AudioPlayer instances allows playing sound effects without interrupting background music - create separate instances for music vs sound effects.
QSoundEffect is more efficient than QMediaPlayer for sound effects - designed for low-latency, frequently-played sounds; cache instances for better performance.
Precaching sound effects at application startup eliminates loading lag - create QSoundEffect instances with setSource() during init, then reuse for instant playback.
Retain temporary QSoundEffect objects in _active_sound_effects until playback finishes to prevent premature garbage collection and audio cut-offs.
Pool-based sound effect architecture is superior to on-demand creation - maintains fixed number of instances per sound (3 max) to prevent memory exhaustion while allowing overlaps.
Thread safety is critical for audio systems - use Lock() for synchronization when multiple UI elements may trigger sounds simultaneously to prevent race conditions.
Sound effect calls now use dedicated play_* functions (e.g., play_buttonhover) defined in audio_utils for each wav; avoid generic helper for low latency.
A minimal music toggle can live in time controls; use global audio utilities and a simple state flag on main window to avoid adding complexity.
Autostarting music can be done safely in `PowerSystemSimulator.__init__` after reset by calling `toggle_music()` once.
On some systems, media playback must be started after the Qt event loop begins; starting in `StartupSequence.run()` with `QTimer.singleShot(0, ...)` ensures reliable first-play.
For background music across multiple tracks, listen to the global audio player's `playback_finished` to advance a playlist and restart from the beginning at the end.
Also connect to a playback error signal and advance on error so a corrupt/missing track doesn't halt music; disconnect both signals when stopping.
Providing a dedicated "Next" control is useful for testing and UX; it should start playlist if stopped and then advance the index.
Floating overlay widgets should be children of `view` and repositioned on resize; containers can be centered between existing anchors by computing left/right bounds every resize.
Marquee labels are easiest to implement with a simple rotating string and QTimer; keep styling consistent by reusing properties panel aesthetics (rgba(37,47,52,0.75), monospace, 1px #555 border).
When music is OFF, set the marquee text to "--" to clearly convey state; update this in both manual toggle-off and no-playable-tracks stop paths.
